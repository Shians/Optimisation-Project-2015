model MeetUp
uses "mmxprs";
setparam("REALFMT", "%.3f")

declarations
	numCities = 5
    numDays = 10
    numPeople = 2
    
	CITIES = 1..numCities
    DAYS = 1..numDays
    PEOPLE = 1..numPeople
	
	location : array(CITIES, DAYS, PEOPLE) of mpvar
	city : array(CITIES, PEOPLE) of mpvar
	move : array(CITIES, CITIES, DAYS, PEOPLE) of mpvar
	daysStay : array(CITIES, DAYS, PEOPLE) of mpvar
	
	together : array(CITIES, DAYS) of mpvar
	daysTogether : linctr
	
	partner : array(CITIES, DAYS) of real
	budget : array(PEOPLE) of integer
	
	names : array(CITIES) of string 
	travel : array(CITIES, CITIES) of integer
	daily : array(CITIES) of integer
	
	baseUtility : array(CITIES) of real
	utility : array(CITIES, DAYS) of real
 	
 	totalUtility : array(PEOPLE) of linctr
 	totalCost : array(PEOPLE) of linctr
end-declarations

function findUtility(city:integer, day:integer):real
	returned := baseUtility(city) * 0.9^day
end-function

names :: (1..5)["Moscow","Paris","London","Madrid","Rome"]

budget :: [500, 200]

baseUtility :: [1.209, 4.483, 4.878, 2.529, 4.2]

forall(c in CITIES) do
	utility(c,1) := baseUtility(c)
end-do

forall(c in CITIES, d in 2..numDays) do
	utility(c,d) := utility(c,d-1) + findUtility(c,d)
end-do

travel :: [0, 146, 126, 202, 146,
		   227, 0, 60, 143, 93,
		   213, 82, 0, 249, 160,
		   188, 86, 136, 0, 144,
		   223, 80, 125, 146, 0]

daily :: [10, 10, 20, 30, 5]

forall(c in CITIES, p in PEOPLE) do
    sum (d in DAYS) daysStay(c, d, p) = city(c, p) ! Only one stay duration is valid for each city, only if city is every visited.
end-do

forall(d in DAYS - {numDays}, f in CITIES, t in CITIES, p in PEOPLE) do
    location(f, d, p) + location(t, d+1, p) <= 1 + move(f, t, d, p)
end-do

forall(d in DAYS, p in PEOPLE) do
    sum (c in CITIES) location(c, d, p) = 1
    sum (f in CITIES, t in CITIES) move(f, t, d, p) = 1
end-do

forall(c in CITIES, d in DAYS, p in PEOPLE) do
	daysStay(c, d, p) * d <= sum(d2 in DAYS) location(c, d2, p) !daysStay(c,d) is one if staying d days in city c
end-do

forall(c in CITIES, d in DAYS, p in PEOPLE) do
    city(c, p) is_binary
    location(c, d, p) is_binary
    daysStay(c, d, p) is_binary
end-do

forall(f in CITIES, t in CITIES, d in DAYS, p in PEOPLE) do
    move(f, t, d, p) is_binary
end-do

forall(p in PEOPLE) do
	totalCost(p) := sum(c in CITIES, d in DAYS) location(c, d, p) * daily(c) +
					sum(f in CITIES, t in CITIES, d in DAYS) move(f, t, d, p) * travel(f, t)
	totalUtility(p) := sum(c in CITIES, d in DAYS) daysStay(c, d, p) * utility(c, d)
end-do

forall(p in PEOPLE) do
	totalCost(p) <= budget(p)
end-do

maximise(totalUtility(1))

totalUtility(1) = totalUtility(1).sol

minimise(totalCost(1))

writeln("Person 1")

writeln("Total Cost: $", totalCost(1).sol)
writeln("Total Utility: ", totalUtility(1).sol)

forall(d in DAYS, c in CITIES) do
    if (location(c, d, 1).sol > 0) then
        writeln("Day ", d, " in ", names(c))
    end-if
end-do

forall(c in CITIES, d in DAYS) do
	partner(c, d) := location(c, d, 1).sol
end-do

forall(c in CITIES, d in DAYS) do
	location(c, d, 2) + partner(c, d) >= 2*together(c, d)
end-do

forall(c in CITIES, d in DAYS) do
	together(c, d) is_binary
end-do

daysTogether := sum(c in CITIES, d in DAYS) together(c, d)

maximise(daysTogether)

daysTogether = daysTogether.sol

maximise(totalUtility(2))

totalUtility(2) = totalUtility(2).sol

minimise(totalCost(2))

writeln("\nPerson 2")

writeln("Total Cost: $", totalCost(2).sol)
writeln("Total Utility: ", totalUtility(2).sol)
writeln("Together : ", daysTogether.sol, " days")

forall(d in DAYS, c in CITIES) do
    if (location(c, d, 2).sol > 0) then
        writeln("Day ", d, " in ", names(c))
    end-if
end-do

end-model
